{"ast":null,"code":"export var ANCHOR_POSITION = {\n  top: {\n    x: 0.5,\n    y: 0\n  },\n  'top-left': {\n    x: 0,\n    y: 0\n  },\n  'top-right': {\n    x: 1,\n    y: 0\n  },\n  bottom: {\n    x: 0.5,\n    y: 1\n  },\n  'bottom-left': {\n    x: 0,\n    y: 1\n  },\n  'bottom-right': {\n    x: 1,\n    y: 1\n  },\n  left: {\n    x: 0,\n    y: 0.5\n  },\n  right: {\n    x: 1,\n    y: 0.5\n  }\n};\nvar ANCHOR_TYPES = Object.keys(ANCHOR_POSITION);\nexport function getDynamicPosition(_ref) {\n  var x = _ref.x,\n    y = _ref.y,\n    width = _ref.width,\n    height = _ref.height,\n    selfWidth = _ref.selfWidth,\n    selfHeight = _ref.selfHeight,\n    anchor = _ref.anchor,\n    _ref$padding = _ref.padding,\n    padding = _ref$padding === void 0 ? 0 : _ref$padding;\n  var _ANCHOR_POSITION$anch = ANCHOR_POSITION[anchor],\n    anchorX = _ANCHOR_POSITION$anch.x,\n    anchorY = _ANCHOR_POSITION$anch.y;\n  var top = y - anchorY * selfHeight;\n  var bottom = top + selfHeight;\n  var yStep = 0.5;\n  if (top < padding) {\n    while (top < padding && anchorY >= yStep) {\n      anchorY -= yStep;\n      top += yStep * selfHeight;\n    }\n  } else if (bottom > height - padding) {\n    while (bottom > height - padding && anchorY <= 1 - yStep) {\n      anchorY += yStep;\n      bottom -= yStep * selfHeight;\n    }\n  }\n  var left = x - anchorX * selfWidth;\n  var right = left + selfWidth;\n  var xStep = 0.5;\n  if (anchorY === 0.5) {\n    anchorX = Math.floor(anchorX);\n    xStep = 1;\n  }\n  if (left < padding) {\n    while (left < padding && anchorX >= xStep) {\n      anchorX -= xStep;\n      left += xStep * selfWidth;\n    }\n  } else if (right > width - padding) {\n    while (right > width - padding && anchorX <= 1 - xStep) {\n      anchorX += xStep;\n      right -= xStep * selfWidth;\n    }\n  }\n  return ANCHOR_TYPES.find(function (positionType) {\n    var anchorPosition = ANCHOR_POSITION[positionType];\n    return anchorPosition.x === anchorX && anchorPosition.y === anchorY;\n  }) || anchor;\n}","map":{"version":3,"names":["ANCHOR_POSITION","top","x","y","bottom","left","right","ANCHOR_TYPES","Object","keys","getDynamicPosition","_ref","width","height","selfWidth","selfHeight","anchor","_ref$padding","padding","_ANCHOR_POSITION$anch","anchorX","anchorY","yStep","xStep","Math","floor","find","positionType","anchorPosition"],"sources":["/home/hp/adeela_map/adeela/node_modules/react-map-gl/src/utils/dynamic-position.js"],"sourcesContent":["// @flow\n\nexport const ANCHOR_POSITION = {\n  top: {x: 0.5, y: 0},\n  'top-left': {x: 0, y: 0},\n  'top-right': {x: 1, y: 0},\n  bottom: {x: 0.5, y: 1},\n  'bottom-left': {x: 0, y: 1},\n  'bottom-right': {x: 1, y: 1},\n  left: {x: 0, y: 0.5},\n  right: {x: 1, y: 0.5}\n};\n\nexport type PositionType = $Keys<typeof ANCHOR_POSITION>;\n\nconst ANCHOR_TYPES = Object.keys(ANCHOR_POSITION);\n\n/**\n * Calculate the dynamic position for a popup to fit in a container.\n * @param {Number} x - x position of the anchor on screen\n * @param {Number} y - y position of the anchor on screen\n * @param {Number} width - width of the container\n * @param {Number} height - height of the container\n * @param {Number} padding - extra space from the edge in pixels\n * @param {Number} selfWidth - width of the popup\n * @param {Number} selfHeight - height of the popup\n * @param {String} anchor - type of the anchor, one of 'top', 'bottom',\n    'left', 'right', 'top-left', 'top-right', 'bottom-left' , and  'bottom-right'\n * @returns {String} position - one of 'top', 'bottom',\n    'left', 'right', 'top-left', 'top-right', 'bottom-left' , and  'bottom-right'\n */\n// eslint-disable-next-line complexity\nexport function getDynamicPosition({\n  x,\n  y,\n  width,\n  height,\n  selfWidth,\n  selfHeight,\n  anchor,\n  padding = 0\n}: {\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  selfWidth: number,\n  selfHeight: number,\n  anchor: PositionType,\n  padding: number\n}): PositionType {\n  let {x: anchorX, y: anchorY} = ANCHOR_POSITION[anchor];\n\n  // anchorY: top - 0, center - 0.5, bottom - 1\n  let top = y - anchorY * selfHeight;\n  let bottom = top + selfHeight;\n  // If needed, adjust anchorY at 0.5 step between [0, 1]\n  const yStep = 0.5;\n\n  if (top < padding) {\n    // Top edge is outside, try move down\n    while (top < padding && anchorY >= yStep) {\n      anchorY -= yStep;\n      top += yStep * selfHeight;\n    }\n  } else if (bottom > height - padding) {\n    // bottom edge is outside, try move up\n    while (bottom > height - padding && anchorY <= 1 - yStep) {\n      anchorY += yStep;\n      bottom -= yStep * selfHeight;\n    }\n  }\n\n  // anchorX: left - 0, center - 0.5, right - 1\n  let left = x - anchorX * selfWidth;\n  let right = left + selfWidth;\n\n  // If needed, adjust anchorX at 0.5 step between [0, 1]\n  let xStep = 0.5;\n  if (anchorY === 0.5) {\n    // If y is centered, then x cannot also be centered\n    anchorX = Math.floor(anchorX);\n    xStep = 1;\n  }\n\n  if (left < padding) {\n    // Left edge is outside, try move right\n    while (left < padding && anchorX >= xStep) {\n      anchorX -= xStep;\n      left += xStep * selfWidth;\n    }\n  } else if (right > width - padding) {\n    // Right edge is outside, try move left\n    while (right > width - padding && anchorX <= 1 - xStep) {\n      anchorX += xStep;\n      right -= xStep * selfWidth;\n    }\n  }\n\n  // Find the name of the new anchor position\n  return (\n    ANCHOR_TYPES.find(positionType => {\n      const anchorPosition = ANCHOR_POSITION[positionType];\n      return anchorPosition.x === anchorX && anchorPosition.y === anchorY;\n    }) || anchor\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}